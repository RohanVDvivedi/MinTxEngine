PICKED

 * make aborting and complete min tx internal logging functions to be called with out locks
 * implement undo for TUPLE_UPDATE_ELEMENT_IN_PLACE with edge cases covered

 * implement checkpointing and management tasks to be done periodically
   * grab exclusive lock on the manager lock
   * if wale file is full create a new one and add it to wa_list
   * add a checkpoint log record
   * calculate the minimum visible LSN and remove log files that are no longer visible
   * count the number of pages that can be truncated in database file (free space mapper page always truncatable, data pages truncatable if free and not write locked) and truncate this file
 * implement recovery function that gets called every time you initialize the mini transaction engine
  * follow aries
    * analyze from the most recent checkpoint log record, if none exists no need to load the contents of checkpoint record
    * redo from the oldest dirty page table's recLSN
    * then mark all active mini transactions to UNDOING_FOR_ABORT with reason being ABORTED_AFTER_CRASH
    * then call mte_complete_mini_tx on all active writer transactions
 * deinitialize_mini_transaction_engine
   * waits for all mini_transactions to be returned
   * also kill the checkpointer thread
   * set a flag stating marked for shutdown
   * modifications to mini_transaction allotter
     * fail wait if the mini_transaction engine is marked for shutdown, after marking for shutdown wake up all waiters waiting for new slot

TESTS
  * multi threaded task of 20 threads
   * insert 10000 random integers -> abort every multiple of 3
   * delete  5000 integers all multiples of 2 -> abort every multiple of 6
   * final result should print first 10000 integers - multiples of 3 - multiples of 2 + multiples of 6
  * write test case where you build a bplus tree and then delete the database file and try reconstructing the complete database using the logs, then compare the database files, or print the bplus tree
  * write test to initialize and print wale_LSNs_from for all wa_list wal_accessors and ensure that they are correctly initialized

 NOTES
  * mini transaction commit does not have to make its changes permanent, so no wal flushing is necessary until it is the last operation of the transaction
  * flushing wal makes up the use amount of the latency of the operation of the mini transaction engine, for main1 test case in test_mindb, flushing wal after every operation jumps the latency from 0.2 seconds 50 seconds
    * current main3 execution time is 13 seconds with 30 threads, by not flushing mini transactions you can bring it down, provind a flag in the mte_complete_mini_tx function that siggests if the changes are permanent
    * find ways to not make mini transactions permanent, while save us 250 folds of latency improvement in a snap

 FAR FUTURE 
 * remove headers not required for public api from publicly installed headers


Tasks necessary to develop MinTxEngine
 * checkpointing is done by writing the mini transaction table and dirty page table to the WALe as a check point record
 * check pointing occurs every T minutes
   * a checkpoint log record is written
   * discard any WALe files whose log records are not visible/required by anyone
   * truncate the database file, if the last page is either a free space mapper page OR is a free page from a committed - not active mini transaction
 * atlast there is a recovery function that must be called as the first line of your application, it recovers from crash
 * add a disk pager module that is allocation module plus Bufferpool + No logging page modification methods + a truncate functionality
   * to be used by transaction and lock table, i.e. non persistent storage of the database for higher level fuinctions