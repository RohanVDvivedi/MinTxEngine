PICKED

 * recover function
   * to be called only upon starting a mini transaction engine
   * only global lock to be held only customarily as noone has access to the mini transaction begin initialized
   * checkpoint analyze(mte)
     * if there is a checkpointLSN != INVALID_LSN, then read it (analyze_from = next_of(checkpointLSN)), else initialize it empty(analyze_from = FIRST_LSN)
     * analyze_at = analyze_from
     * loop while(analyze_at != INVALID_LSN)
       * lr = read(analyze_at), analyze_at = next_of(analyze_at)
       * maintain dpt
         * if unidentified
           * exit();
         * if forward change log OR FPW
           * if page alloc/dealloc
             * add page and free space mapper page to dpt, if not present in dpt
           * else
             * add page to dpt, if not present in dpt
         * if clr
             * read corresponding lr
               * if page alloc/dealloc add free space mapper page to dpt, if not present in dpt
               * else if forward change log, add page to dpt, if not present in dpt
               * else exit() -> presence of compensation log record for a possibly valid by inappropriate log record, plausible bug in mini transaction engine
         * else skip
       * maintain mtt
         * if unidentified
           * exit();
         * if forward change log
           * mt = mtt.find(lr.mtx_id)
           * if mt = NULL then mt = mtt.insert(lr.mtx_id, in_progress)
           * if mt.state != in_progress exit()
           * mt.lastLSN = analyze_at
         * if FPW
           * mt = mtt.find(lr.mtx_id)
           * if mt = NULL then mt = mtt.insert(lr.mtx_id, in_progress)
           * mt.lastLSN = analyze_at
         * if abort log
           * mt = mtt.find(lr.mtx_id)
           * if mt = NULL exit() -> abort log record for an in existent mini transaction, plausible log corruption or bug in mini transaction engine
           * if mt.state != in_progress && mt.state != aborted -> exit() -> invalid mini transaction state transition detected
           * mt.state = undoing_for_abort
           * mt.lastLSN = analyze_at
         * if clr
           * mt = mtt.find(lr.mtx_id)
           * if mt = NULL exit() -> abort log record for an in existent mini transaction, plausible log corruption or bug in mini transaction engine
           * if mt.state != undoing_for_abort -> exit() -> invalid mini transaction state transition detected
           * mt.lastLSN = analyze_at
         * if complete log
           * mt = mtt.find(lr.mtx_id)
           * if mt = NULL exit() -> abort log record for an in existent mini transaction, plausible log corruption or bug in mini transaction engine
           * if mt.state != in_progress && mt.state != undoing_for_abort -> exit() -> invalid mini transaction state transition detected
           * remove mt from mtt
   * redo(mte, checkpoint ckpt)
     * redo_at = min_recLSN(ckpt.dpt)
     * restore the mtt from checkpoint variable to mte's writer transactions
     * while(redo_at != INVALID_LSN)
       * lr = read_at(redo_at), redo_at = next_of(redo_at);
       * TODO
   * undo
     * fetch mini transactions one by one from the mini transaction engine
      * make their page_latches_held_counter = 0 and reference_counter = 1
     * mark them aborted due to crash
     * call mte_complete_mini_tx on them one by one

  * NOTE :: after adding any type of log record ensure that it's case is covered explicityly in undo (*allotment.c) and redo-recovery functions (*recovery.c)

  * PAGE_ALLOCATION OPTIMIZATION
  * implement a cache for free space mapper page ids with most free pages in increasing order of their page ids, and use them for faster allocation
    * like a separate faster allocation case which checks these free space mapper pages first, then fall backs to current code
    * also update this cache when a new page is allocated or freed
    * this cache should be randomized to randomly select pages for allocation
    * do this caching while releasing latch on the free space mapper page
    * simple API like
      * void update_free_space_mapper_page_in_availability_cache_UNSAFE(mini_transaction_engine* mte, const void* free_space_mapper_page, uint64_t free_space_mapper_page_id); // to be called when ever you release a latch on the free space mapper page
      * uint64_t get_any_free_space_mapper_page_from_availability_cache_UNSAFE(mini_transaction_engine* mte); // return of 0, implies nothing available
        * this will not give you enough information as you also need to check that the corresponding page we decide to allocate also needs to be not write locked

  * DISK SPACE RENUNCIATION BACK TO OS
  * management in perform_checkpoint_UNSAFE(mte)
   * calculate the minimum LSN that can stay alive min(mt->mini_transaction_id-s, dpte->recLSN-s, checkpoint_begin_LSN, user defined value from the call back)
     * discard old wal files if possible
   * if last wal file is greater than Y MBs, then create a new wal file and insert it in wa_list
   * start from the last page and count new size of the database
     * truncate database file
     * update database_page_count variable
     * need some mechanism to explicitly discard those pages from the cache - OR not, everything is already flushed to disk

TESTS
  * main1, main2 and main3 with variable length tuples
    same key but value = output of the following
    const char *ones[] = {
  "zero", "one", "two", "three", "four", "five", "six", "seven",
  "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen",
  "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"
};

const char *tens[] = {
  ", ", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"
};

char *number_to_words(int n) {
  static char output[20];
  if (n < 20) {
    strcpy(output, ones[n]);
  } else if (n < 100) {
    sprintf(output, "%s-%s", tens[n / 10], ones[n % 10]);
  } else {
    sprintf(output, "%s hundred %s", ones[n / 100], number_to_words(n % 100));
  }
  return output;
}
  * write test case where you build a bplus tree and then delete the database file and try reconstructing the complete database using the logs, then compare the database files, or print the bplus tree
  * write test to initialize and print wale_LSNs_from for all wa_list wal_accessors and ensure that they are correctly initialized

 NOTES
  * mini transaction commit does not have to make its changes permanent, so no wal flushing is necessary until it is the last mini transaction operation of the transaction
  * flushing of abort_mini_tx log record is necessary as you can read changes of its prior log records that are to be undine until the abort log record of minitransaction is flushed
  * flushing wal makes up the use amount of the latency of the operation of the mini transaction engine, for main1 test case in test_mindb, flushing wal after every operation jumps the latency from 0.2 seconds 50 seconds
    * current main3 execution time is 13 seconds with 30 threads, by not flushing mini transactions you can bring it down, provind a flag in the mte_complete_mini_tx function that siggests if the changes are permanent
    * find ways to not make mini transactions permanent, while save us 250 folds of latency improvement in a snap

 FAR FUTURE 
 * remove headers not required for public api from publicly installed headers
   * like dirty_page_table_entry.h and log_record.h
 * configure this in future MINIMIM_CHECKPOINTING_LSN_DIFF


Tasks necessary to develop MinTxEngine
 * checkpointing is done by writing the mini transaction table and dirty page table to the WALe as a check point record
 * check pointing occurs every T minutes
   * a checkpoint log record is written
   * discard any WALe files whose log records are not visible/required by anyone
   * truncate the database file, if the last page is either a free space mapper page OR is a free page from a committed - not active mini transaction
 * atlast there is a recovery function that must be called as the first line of your application, it recovers from crash
 * add a disk pager module that is allocation module plus Bufferpool + No logging page modification methods + a truncate functionality
   * to be used by transaction and lock table, i.e. non persistent storage of the database for higher level fuinctions