PICKED

  * NOTE :: after adding any type of log record ensure that it's case is covered explicityly in undo (*allotment.c) and redo-recovery functions (*recovery.c)
    * do this by performing `grep --include "*.c" -inr "switch(.*type)" .`

  * PAGE_ALLOCATION OPTIMIZATION
  * implement a cache for free space mapper page ids with most free pages in increasing order of their page ids, and use them for faster allocation
    * like a separate faster allocation case which checks these free space mapper pages first, then fall backs to current code
    * also update this cache when a new page is allocated or freed
    * this cache should be randomized to randomly select pages for allocation
    * do this caching while releasing latch on the free space mapper page
    * simple API like
      * void update_free_space_mapper_page_in_availability_cache_UNSAFE(mini_transaction_engine* mte, const void* free_space_mapper_page, uint64_t free_space_mapper_page_id); // to be called when ever you release a latch on the free space mapper page
      * uint64_t get_any_free_space_mapper_page_from_availability_cache_UNSAFE(mini_transaction_engine* mte); // return of 0, implies nothing available
        * this will not give you enough information as you also need to check that the corresponding page we decide to allocate also needs to be not write locked

  * DISK SPACE RENUNCIATION BACK TO OS
  * management in perform_checkpoint_UNSAFE(mte)
   * calculate the minimum LSN that can stay alive min(mt->mini_transaction_id-s, dpte->recLSN-s, checkpoint_begin_LSN, user defined value from the call back)
     * discard old wal files if possible
   * if last wal file is greater than Y MBs, then create a new wal file and insert it in wa_list
   * start from the last page and count new size of the database
     * truncate database file
     * update database_page_count variable
     * need some mechanism to explicitly discard those pages from the cache - OR not, everything is already flushed to disk

 * there can be torn writes, if the database crashes during a write page call
  * to avoid this do not perform checksum validation while reading a page into the dsk during the recovery
  * need some mechanism to let the bufferpool callbacks know that it is recovery time so they can skip checking checksum
  * do not worry our FULL_PAGE_WRITEs and recovery fixes torn writes

TESTS
  * main1, main2 and main3 with variable length tuples
    same key but value = output of the following
    const char *ones[] = {
  "zero", "one", "two", "three", "four", "five", "six", "seven",
  "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen",
  "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"
};

const char *tens[] = {
  ", ", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"
};

char *number_to_words(int n) {
  static char output[20];
  if (n < 20) {
    strcpy(output, ones[n]);
  } else if (n < 100) {
    sprintf(output, "%s-%s", tens[n / 10], ones[n % 10]);
  } else {
    sprintf(output, "%s hundred %s", ones[n / 100], number_to_words(n % 100));
  }
  return output;
}
  * write test to initialize and print wale_LSNs_from for all wa_list wal_accessors and ensure that they are correctly initialized

 NOTES
  * mini transaction commit does not have to make its changes permanent, so no wal flushing is necessary until it is the last mini transaction operation of the transaction
  * flushing of abort_mini_tx log record is necessary as you can read changes of its prior log records that are to be undine until the abort log record of minitransaction is flushed
  * flushing wal makes up the use amount of the latency of the operation of the mini transaction engine, for main1 test case in test_mindb, flushing wal after every operation jumps the latency from 0.2 seconds 50 seconds
    * current main3 execution time is 13 seconds with 30 threads, by not flushing mini transactions you can bring it down, provind a flag in the mte_complete_mini_tx function that siggests if the changes are permanent
    * find ways to not make mini transactions permanent, while save us 250 folds of latency improvement in a snap

 FAR FUTURE 
 * remove headers not required for public api from publicly installed headers
   * like dirty_page_table_entry.h and log_record.h
 * configure this in future MINIMIM_CHECKPOINTING_LSN_DIFF


Tasks necessary to develop MinTxEngine
 * check pointing occurs every T minutes
   * discard any WALe files whose log records are not visible/required by anyone
   * truncate the database file, if the last page is either a free space mapper page OR is a free page from a committed - not active mini transaction
 * add a disk pager module that is allocation module plus Bufferpool + No logging page modification methods + a truncate functionality
   * to be used by transaction and lock table, i.e. non persistent storage of the database for higher level fuinctions