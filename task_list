PICKED

 * add check pointing log record type
   * add ckecpoint log record types
     * CHECKPOINT_MINI_TRANSACTION_TABLE_ENTRY
       * prev_log_record_LSN
       * mini_transaction
     * CHECKPOINT_DIRTY_PAGE_TABLE_ENTRY
       * prev_log_record_LSN
       * dirty_page_table_entry
     * CHECKPOINT_END
       * prev_log_record_LSN
       * checkpoint_begin_LSN
   * and its corresponding function cases to serialize and deserialize it
   * and its tuple and type definition to encapsulate dirty page table entry and mini transaction table entry

 * checkpointer utility
   * add a checkpoint struct
     * uint256 checkpoint_begin_LSN
     * hashtable writer_mini_transactions
     * hashtable dirty_page_table
   * utility function to read whole checkpoint given checkpoint_end_LSN
     * exit(-1) if any of the LSNs fail to be read or any of the log records are not checkpoint LSNs of desired type
     * mini transaction related log records and user log records must not be present in check point log record sequence
   * utility function to append whole checkpoint struct to latest wale log, and return the begin and end checkpoint LSNs

 * deinitialize_mini_transaction_engine
   * mark shutdown flag -> most of it to be done with shared lock
   * OPTIONAL :: mark all active mini transactions aborted
   * wake up checkpointer
   * wake up all waiting for the execution slot
   * waits for all mini_transactions to be completed -> wait on wait_for_execution slot for this and keep checking the reader and writer mini transaction to become empty
   * wait for checkpointer to quit
   * release all memory and quit
   * modifications to mini_transaction allotter
     * fail wait if the mini_transaction engine is marked for shutdown, after marking for shutdown wake up all waiters waiting for new slot

 * add checkpointer thread
   * wait on wait_wake_checkpointer for checkpointer period -> important to be done outside exclusive manager lock
   * if shut down flag set quit
   * take exclusive manager lock
     * flush wale
     * checkpointing necessary only if last checkpoint_end_LSN - flushedLSN was atleast some MBs away preferably 10
     * turn off periodic flush job, and wait for it to finish
     * flush bufferpool
     * create checkpoint log record with shallow copy and serialize it
     * log checkpoint log record and flush, flush only all of the checkpoint of none of it
     * calculate the minimum LSN that can stay alive min(mt->mini_transaction_id-s, dpte->recLSN-s, checkpoint_begin_LSN, user defined value from the call back)
       * discard old wal files if possible
     * start from the last page and count new size of the database
       * truncate database file
       * update database_page_count variable
     * you can release mutex now
   * release exclusive manager lock

 * recover function
   * get latest checkpoint log record, OR initialize it empty
   * copy checkpoint log record's mini transaction table and dirty page table to local variables
   * analyze loop acts on the local variables (created above) only, starting from checkpoint log record
     * if log record is a change, add page to dirty page table with respective recLSN
     * if mini_transaction with given id does not exist, create a new one in mini transaction table, update lastLSN
     * if it is abort mini tx, mark the mini transaction as UNDOING for abort with specified abort error, update lastLSN
     * if it is complete mini tx, make the mini transaction as completed, and remove it from the , update lastLSN
   * now calculate the min of dirty page table -> recLSN, call it redo_from_LSN
     * loop from redo_from_LSN until the end
       * TODO ::

  * NOTE :: after adding any type of lof record ensure that it's case is covered explicityly in undo (*allotment.c) and redo-recovery functions (*recovery.c)

  * PAGE_ALLOCATION OPTIMIZATION
  * implement a cache for free space mapper page ids with most free pages in increasing order of their page ids, and use them for faster allocation
    * like a separate faster allocation case which checks these free space mapper pages first, then fall backs to current code
    * also update this cache when a new page is allocated or freed
    * this cache should be randomized to randomly select pages for allocation
    * do this caching while releasing latch on the free space mapper page
    * simple API like
      * void update_free_space_mapper_page_in_availability_cache_UNSAFE(mini_transaction_engine* mte, const void* free_space_mapper_page, uint64_t free_space_mapper_page_id); // to be called when ever you release a latch on the free space mapper page
      * uint64_t get_any_free_space_mapper_page_from_availability_cache_UNSAFE(mini_transaction_engine* mte); // return of 0, implies nothing available
        * this will not give you enough information as you also need to check that the corresponding page we decide to allocate also needs to be not write locked


TESTS
  * main1, main2 and main3 with variable length tuples
  * write test case where you build a bplus tree and then delete the database file and try reconstructing the complete database using the logs, then compare the database files, or print the bplus tree
  * write test to initialize and print wale_LSNs_from for all wa_list wal_accessors and ensure that they are correctly initialized

 NOTES
  * mini transaction commit does not have to make its changes permanent, so no wal flushing is necessary until it is the last mini transaction operation of the transaction
  * flushing of abort_mini_tx log record is necessary as you can read changes of its prior log records that are to be undine until the abort log record of minitransaction is flushed
  * flushing wal makes up the use amount of the latency of the operation of the mini transaction engine, for main1 test case in test_mindb, flushing wal after every operation jumps the latency from 0.2 seconds 50 seconds
    * current main3 execution time is 13 seconds with 30 threads, by not flushing mini transactions you can bring it down, provind a flag in the mte_complete_mini_tx function that siggests if the changes are permanent
    * find ways to not make mini transactions permanent, while save us 250 folds of latency improvement in a snap

 FAR FUTURE 
 * remove headers not required for public api from publicly installed headers


Tasks necessary to develop MinTxEngine
 * checkpointing is done by writing the mini transaction table and dirty page table to the WALe as a check point record
 * check pointing occurs every T minutes
   * a checkpoint log record is written
   * discard any WALe files whose log records are not visible/required by anyone
   * truncate the database file, if the last page is either a free space mapper page OR is a free page from a committed - not active mini transaction
 * atlast there is a recovery function that must be called as the first line of your application, it recovers from crash
 * add a disk pager module that is allocation module plus Bufferpool + No logging page modification methods + a truncate functionality
   * to be used by transaction and lock table, i.e. non persistent storage of the database for higher level fuinctions