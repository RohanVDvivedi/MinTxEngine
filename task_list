PICKED
 * implement mte_complete_mini_tx function
   * decrements the reference counter of the mini transaction at the end of this function
   * if the mini_tx_id == INVALID, it is a reader transaction, nothing needs to be done
   * if transaction is in IN_PROGRESS state, put COMPLETE_MINI_TX log record and flush all logs 
   * if transaction is in ABORTED state, put ABORT_MINI_TX log record, start undoing from where you left off until you reach COMPLETE_MINI_TX log record
     * if lastLSN is a regular modification log record put ABORT_MINI_TX log record and flush all log records
     * if lastLSN is ABORT_MINI_TX, start a loop from its previous log record
     * if lastLSN is CLR, start a loop from is next_log_record_to_undo
     * do it until you read the log record whose prev_log_record_LSN is INVALID
     * then finally put COMPLETE_MINI_TX log record and flush all log records
   * for generating clr records in a loop
     * always take shared lock on the manager_lock inside the loop, for every iteration
     * generate full page write log record as necessary
     * always take latch in write mode, and wait indefinitely until you get the lock
     * always skip FULL_PAGE_WRITE log records
     * only flip the bit in the PAGE_DE/ALLOCATION log records
     * undo operations to page modifications in reverse, perform compaction and tuple copy and then inserts as and when needed
     * pageLSN, and mt->lastLSN are always to be set to the lsn of the CLR log record, that we just generated
     * writerLSN of no pages are to be changed

 * exit(-1) the process on an IO error in bufferpool or WALe's callbacks
 * implement logic to insert 10000 multiples of 10, iterating i from 0 to 9999 (both inclusive), inserting 0 to 99990, and abort where i is also multiple of 23
 * print the bplus tree in the end to ensure that the test passed

 * implement recovery function that gets called every time you initialize the mini transaction engine
  * analyze, redo then mark all active mini transactions to UNDOING_FOR_ABORT with reason being ABORTED_AFTER_CRASH and then call complete_mini_transaction on all active writer transactions
 * deinitialize_mini_transaction_engine waits for all mini_transactions to be returned
   * also kill the checkpointer thread
   * set a flag stating marked for shutdown
   * modifications to mini_transaction allotter
     * fail wait if the mini_transaction engine is marked for shutdown, after marking for shutdown wake up all waiters waiting for new slot
 * write test case where you build a bplus tree and then delete the database file and try reconstructing the complete database using the logs, then compare the database files, or print the bplus tree
 * write test to initialize and print wale_LSNs_from for all wa_list wal_accessors and ensure that they are correctly initialized
 * implement a deinitialize function for mini transaction engine
 * add a flag suggesting shutdown of the mini transaction engine
 * fail all new calls if the shut_down flag is set, and wait for shutdown by taking a manager exclusive lock
 * implement checkpointing and management tasks to be done periodically
   * if wale file is full create a new one and add it to wa_list
   * add a checkpoint log record
   * calculate the minimum visible LSN and remove log files that are no longer visible
   * count the number of pages that can be truncated in database file (free space mapper page always truncatable, data pages truncatable if free and not write locked) and truncate this file

 FAR FUTURE 
 * remove headers not required for public api from publicly installed headers


Tasks necessary to develop MinTxEngine
 * checkpointing is done by writing the mini transaction table and dirty page table to the WALe as a check point record
 * check pointing occurs every T minutes
   * there has to be a check pointing reader/writer lock
   * taken by every one in shared mode and the checkpointer as exclusive mode
   * a checkpoint log record is written
   * discard any WALe files whose log records are not visible/required by anyone
   * truncate the Bufferpool file if the last extent is all is_valid = 0 bits
 * atlast there is a recovery function that must be called as the first line of your application, it recovers from crash
 * add a disk pager module that is allocation module plus Bufferpool + No logging page modification methods + a truncate functionality
   * to be used by transaction and lock table, i.e. non persistent storage of the database for higher level fuinctions