PICKED

 * multi threaded task of 20 threads
   * insert 10000 random integers -> abort every multiple of 3
   * delete  5000 integers all multiples of 2 -> abort every multiple of 6
   * final result should print first 10000 integers - multiples of 3 - multiples of 2 + multiples of 6

 * implement undo for TUPLE_UPDATE_ELEMENT_IN_PLACE with edge cases covered

 * implement recovery function that gets called every time you initialize the mini transaction engine
  * analyze, redo then mark all active mini transactions to UNDOING_FOR_ABORT with reason being ABORTED_AFTER_CRASH and then call complete_mini_transaction on all active writer transactions
 * deinitialize_mini_transaction_engine waits for all mini_transactions to be returned
   * also kill the checkpointer thread
   * set a flag stating marked for shutdown
   * modifications to mini_transaction allotter
     * fail wait if the mini_transaction engine is marked for shutdown, after marking for shutdown wake up all waiters waiting for new slot
 * write test case where you build a bplus tree and then delete the database file and try reconstructing the complete database using the logs, then compare the database files, or print the bplus tree
 * write test to initialize and print wale_LSNs_from for all wa_list wal_accessors and ensure that they are correctly initialized
 * implement a deinitialize function for mini transaction engine
 * add a flag suggesting shutdown of the mini transaction engine
 * fail all new calls if the shut_down flag is set, and wait for shutdown by taking a manager exclusive lock
 * implement checkpointing and management tasks to be done periodically
   * if wale file is full create a new one and add it to wa_list
   * add a checkpoint log record
   * calculate the minimum visible LSN and remove log files that are no longer visible
   * count the number of pages that can be truncated in database file (free space mapper page always truncatable, data pages truncatable if free and not write locked) and truncate this file

 FAR FUTURE 
 * remove headers not required for public api from publicly installed headers


Tasks necessary to develop MinTxEngine
 * checkpointing is done by writing the mini transaction table and dirty page table to the WALe as a check point record
 * check pointing occurs every T minutes
   * there has to be a check pointing reader/writer lock
   * taken by every one in shared mode and the checkpointer as exclusive mode
   * a checkpoint log record is written
   * discard any WALe files whose log records are not visible/required by anyone
   * truncate the Bufferpool file if the last extent is all is_valid = 0 bits
 * atlast there is a recovery function that must be called as the first line of your application, it recovers from crash
 * add a disk pager module that is allocation module plus Bufferpool + No logging page modification methods + a truncate functionality
   * to be used by transaction and lock table, i.e. non persistent storage of the database for higher level fuinctions