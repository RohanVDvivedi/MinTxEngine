PICKED

 * build a utility function to flush wale logs of the latest wale
   * refactor the code everywhere to use this UNSAFE function to flush logs
 * build a utility function to latch pages with a flush if required
 * all exit(-1) get their own print statements to describe what is the bug

 * implement logic to insert 10000 multiples of 10, iterating i from 0 to 9999 (both inclusive), inserting 0 to 99990, and abort where i is also multiple of 23
 * print the bplus tree in the end to ensure that the test passed

 * exit(-1) the process on an IO error in bufferpool or WALe's callbacks
   * validate checksum on pages when the pages are being written or read from database file in bufferpool callbacks
 * implement undo for TUPLE_UPDATE_ELEMENT_IN_PLACE with edge cases covered

 * implement recovery function that gets called every time you initialize the mini transaction engine
  * analyze, redo then mark all active mini transactions to UNDOING_FOR_ABORT with reason being ABORTED_AFTER_CRASH and then call complete_mini_transaction on all active writer transactions
 * deinitialize_mini_transaction_engine waits for all mini_transactions to be returned
   * also kill the checkpointer thread
   * set a flag stating marked for shutdown
   * modifications to mini_transaction allotter
     * fail wait if the mini_transaction engine is marked for shutdown, after marking for shutdown wake up all waiters waiting for new slot
 * write test case where you build a bplus tree and then delete the database file and try reconstructing the complete database using the logs, then compare the database files, or print the bplus tree
 * write test to initialize and print wale_LSNs_from for all wa_list wal_accessors and ensure that they are correctly initialized
 * implement a deinitialize function for mini transaction engine
 * add a flag suggesting shutdown of the mini transaction engine
 * fail all new calls if the shut_down flag is set, and wait for shutdown by taking a manager exclusive lock
 * implement checkpointing and management tasks to be done periodically
   * if wale file is full create a new one and add it to wa_list
   * add a checkpoint log record
   * calculate the minimum visible LSN and remove log files that are no longer visible
   * count the number of pages that can be truncated in database file (free space mapper page always truncatable, data pages truncatable if free and not write locked) and truncate this file

 FAR FUTURE 
 * remove headers not required for public api from publicly installed headers


Tasks necessary to develop MinTxEngine
 * checkpointing is done by writing the mini transaction table and dirty page table to the WALe as a check point record
 * check pointing occurs every T minutes
   * there has to be a check pointing reader/writer lock
   * taken by every one in shared mode and the checkpointer as exclusive mode
   * a checkpoint log record is written
   * discard any WALe files whose log records are not visible/required by anyone
   * truncate the Bufferpool file if the last extent is all is_valid = 0 bits
 * atlast there is a recovery function that must be called as the first line of your application, it recovers from crash
 * add a disk pager module that is allocation module plus Bufferpool + No logging page modification methods + a truncate functionality
   * to be used by transaction and lock table, i.e. non persistent storage of the database for higher level fuinctions